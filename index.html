<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Not Coins 2.0 — Improved Web Build</title>
<style>
  :root{
    --bg:#071325;
    --panel:#081224;
    --muted:#9fb0c8;
    --accent:#7c5cff;
    --success:#21c07b;
    --danger:#ff6b6b;
    --glass: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    background: linear-gradient(180deg,#04101a,#071325 60%);
    color:#e6eef8;
    padding:20px;
    display:flex;
    justify-content:center;
    align-items:flex-start;
    min-height:100vh;
  }

  .app {
    width:1100px;
    max-width:calc(100% - 40px);
    display:grid;
    grid-template-columns: 1fr 360px;
    gap:18px;
  }

  .card {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:12px;
    padding:14px;
    border:1px solid rgba(255,255,255,0.03);
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
  }

  .game-wrap { display:flex; flex-direction:column; gap:12px; }
  #gameCanvas {
    width:100%;
    height:560px;
    border-radius:8px;
    display:block;
    background: linear-gradient(180deg,#0b2a3b,#042031);
  }

  .controls { display:flex; justify-content:space-between; align-items:center; gap:8px; }
  .left-controls{ display:flex; gap:8px; align-items:center;}
  .stat { padding:8px 10px; border-radius:8px; background:var(--glass); color:var(--muted); font-weight:700; min-width:90px; text-align:center;}
  button.btn { border:none; padding:8px 12px; border-radius:8px; font-weight:700; cursor:pointer; background:linear-gradient(180deg,var(--accent), #5b46d9); color:white; box-shadow: 0 6px 18px rgba(90,64,200,0.18); }
  button.ghost { background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--muted); }

  .sidebar { display:flex; flex-direction:column; gap:12px; }
  .player-panel label{ display:block; color:var(--muted); font-size:13px; margin-bottom:6px; }
  input[name="playerName"]{ width:100%; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit; font-weight:700; }
  .lead-list { display:flex; flex-direction:column; gap:8px; max-height:360px; overflow:auto; padding-right:6px; }
  .lead-item { display:flex; justify-content:space-between; align-items:center; gap:8px; padding:8px; border-radius:8px; background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent); border:1px solid rgba(255,255,255,0.02); }
  .lead-item .name{ font-weight:800; }
  .lead-item .score{ color:var(--accent); font-weight:900; }

  .msg{ color:var(--muted); font-size:13px }
  footer.tip{ color:var(--muted); font-size:12px; text-align:center; margin-top:8px; }

  @media (max-width:980px){
    .app{ grid-template-columns: 1fr; }
    #gameCanvas{ height:54vh; }
  }
</style>
</head>
<body>
  <div class="app">
    <div class="card game-wrap" aria-label="Not Coins game area">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <h2 style="margin:0;font-size:18px">Not Coins 2.0 — Improved</h2>
          <div class="msg">Platformer-style, collect coins, avoid enemies. Arrow/WASD, touch controls supported.</div>
        </div>
        <div style="color:var(--muted);font-weight:700">v1.1 — improved</div>
      </div>

      <canvas id="gameCanvas" width="880" height="560" aria-label="Game canvas"></canvas>

      <div class="controls">
        <div class="left-controls">
          <div class="stat">Score <div id="score" style="font-size:18px;color:#fff">0</div></div>
          <div class="stat">Lives <div id="lives" style="font-size:18px;color:#fff">3</div></div>
          <div class="stat">Level <div id="level" style="font-size:18px;color:#fff">1</div></div>
        </div>
        <div style="display:flex; gap:8px;">
          <button id="pauseBtn" class="btn ghost">Pause</button>
          <button id="restartBtn" class="btn">Restart</button>
        </div>
      </div>

      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:6px">
        <div class="msg">Tip: collect coin clusters for combo bonus.</div>
        <div class="msg">Game submits score on game over.</div>
      </div>
    </div>

    <div class="card sidebar" aria-label="Leaderboard and player">
      <div class="player-panel">
        <label for="playerName">Player name (saved once)</label>
        <div style="display:flex;gap:8px">
          <input id="playerName" name="playerName" placeholder="Enter name (2+ chars)" />
          <button id="saveNameBtn" class="btn">Save</button>
        </div>
        <div id="nameHelp" class="msg">Enter a name once — it will be saved locally and locked.</div>
      </div>

      <div>
        <h3 style="margin:0 0 8px 0">Leaderboard</h3>
        <div id="leaderboard" class="lead-list" aria-live="polite">
          <div class="msg">Loading leaderboard…</div>
        </div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="refreshBtn" class="btn ghost">Refresh</button>
          <button id="showAllBtn" class="btn ghost">Show All</button>
        </div>
      </div>

      <div style="margin-top:auto">
        <div id="networkMsg" class="msg"></div>
        <footer class="tip">Leaderboard: MockAPI (public). Want private hosting? I can help.</footer>
      </div>
    </div>
  </div>

<script>
/* ===================================================================
   Not Coins 2.0 — Improved single-file web version
   - Tile-based platformer with coin clusters, enemies, levels
   - Player name locked in localStorage
   - Leaderboard integration (MockAPI)
   - Procedural pixel visuals and WebAudio SFX (no external assets)
   =================================================================== */

const API_BASE = 'https://68f3dd3efd14a9fcc42a1184.mockapi.io/notcoins';
const MAX_LEAD_DISPLAY = 12;

/* ============ Canvas and UI ============ */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const levelEl = document.getElementById('level');

const pauseBtn = document.getElementById('pauseBtn');
const restartBtn = document.getElementById('restartBtn');

const playerNameInput = document.getElementById('playerName');
const saveNameBtn = document.getElementById('saveNameBtn');
const nameHelp = document.getElementById('nameHelp');

const refreshBtn = document.getElementById('refreshBtn');
const showAllBtn = document.getElementById('showAllBtn');
const leaderboardEl = document.getElementById('leaderboard');
const networkMsg = document.getElementById('networkMsg');

function fitCanvas(){ 
  const rect = canvas.getBoundingClientRect();
  // preserve pixel-y look by using devicePixelRatio
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.max(480, Math.floor(rect.width * dpr));
  canvas.height = Math.max(320, Math.floor(rect.height * dpr));
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
fitCanvas();
window.addEventListener('resize', fitCanvas);

/* ============ Game Config ============ */
const TILE = 40;
const GRAVITY = 0.9;
const FRICTION = 0.86;
const JUMP_V = -14;

let game = {
  running: true,
  paused: false,
  score: 0,
  lives: 3,
  level: 1,
  mapIndex: 0,
  maps: [],
  player: null,
  coins: [],
  enemies: [],
  time: 0,
  comboTimer: 0
};

/* ============ Simple procedural visuals ============ */
function drawRect(x,y,w,h,fill){
  ctx.fillStyle = fill;
  ctx.fillRect(Math.round(x), Math.round(y), Math.round(w), Math.round(h));
}
function drawText(txt,x,y,size='16px',align='left'){ ctx.fillStyle = '#eaf4ff'; ctx.font = `${size} Inter, system-ui`; ctx.textAlign = align; ctx.fillText(txt,x,y); }

/* ============ Build simple tile maps (arrays) ============
   0 = empty, 1 = ground, 2 = coin, 3 = enemy spawn, 4 = platform
   maps designed in grid of columns x rows
*/
function createMaps(){
  const w = 22, h = 14;
  const empty = () => Array.from({length:h},()=>Array(w).fill(0));
  // map 1: simple starter
  let m1 = empty();
  for(let x=0;x<w;x++){ m1[h-2][x]=1; m1[h-1][x]=1; } // ground
  // platforms
  m1[9][4]=4; m1[9][5]=4; m1[8][12]=4; m1[8][13]=4; m1[6][16]=4; m1[6][17]=4;
  // coins
  m1[8][4]=2; m1[8][5]=2; m1[7][12]=2; m1[7][13]=2; m1[5][16]=2; m1[5][17]=2;
  // enemies
  m1[h-3][10]=3;
  // map 2: mid difficulty
  let m2 = empty();
  for(let x=0;x<w;x++){ m2[h-2][x]=1; m2[h-1][x]=1; }
  m2[10][2]=4; m2[10][3]=4; m2[9][7]=4; m2[9][8]=4; m2[7][12]=4; m2[7][13]=4; m2[6][17]=4;
  // coins clusters
  m2[9][2]=2; m2[8][7]=2; m2[6][12]=2; m2[5][17]=2; m2[11][14]=2; m2[11][15]=2;
  m2[h-3][5]=3; m2[h-3][15]=3; // enemies
  // map 3: harder
  let m3 = empty();
  for(let x=0;x<w;x++){ m3[h-2][x]=1; m3[h-1][x]=1; }
  // scatter platforms and coins
  for(let i=2;i<20;i+=3){ if(i%2===0) m3[8][i]=4, m3[7][i]=2; else m3[10][i]=4, m3[9][i]=2; }
  m3[h-3][6]=3; m3[h-3][12]=3; m3[h-3][18]=3;
  return [m1,m2,m3];
}

/* ============ Entities ============ */
function spawnPlayer(){
  game.player = {
    x: 80, y: canvas.height/ (window.devicePixelRatio||1) - TILE*3,
    w: 28, h: 38,
    vx:0, vy:0, speed:0.35,
    grounded:false, facing:1, color:'#57b0ff',
    dead:false
  };
}
function spawnFromMap(map){
  game.coins = [];
  game.enemies = [];
  const rows = map.length, cols = map[0].length;
  const cellW = TILE, cellH = TILE;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const v = map[r][c];
      const px = c*cellW + 8;
      const py = r*cellH + 8;
      if(v===2){
        game.coins.push({ x: px + 4, y: py + 4, w:20, h:20, collected:false, value:1 });
      } else if(v===3){
        // enemy patrol
        game.enemies.push({ x: px, y: py, w:32, h:28, dir: Math.random()<0.5?-1:1, speed: 0.6 + Math.random()*0.6 });
      }
    }
  }
}

/* ========= Map collision helpers ========= */
function tileAtPixel(map,x,y){
  const col = Math.floor(x / TILE);
  const row = Math.floor(y / TILE);
  if(row<0||row>=map.length||col<0||col>=map[0].length) return 0;
  return map[row][col];
}
function isSolid(tile){ return tile===1; }

/* ============ Input ============ */
const keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(['arrowup',' '].includes(e.key.toLowerCase())) e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

/* simple touch control */
let touch = { active:false, x:0 };
canvas.addEventListener('touchstart', e => { touch.active=true; touch.x = e.touches[0].clientX; });
canvas.addEventListener('touchmove', e => { touch.x = e.touches[0].clientX; });
canvas.addEventListener('touchend', e => { touch.active=false; keys[' '] = true; setTimeout(()=>keys[' ']=false,120); });

/* ============ Game state & logic ============ */
function resetLevel(index=0){
  game.mapIndex = index;
  game.level = index+1;
  const map = game.maps[index];
  spawnPlayer();
  spawnFromMap(map);
  game.score = 0;
  game.lives = 3;
  game.time = 0;
  game.comboTimer = 0;
  updateHUD();
}

function nextLevel(){
  const next = Math.min(game.maps.length-1, game.mapIndex+1);
  if(next === game.mapIndex) {
    // loop but increase difficulty (speed up enemies)
    for(const e of game.enemies) e.speed *= 1.15;
  } else {
    game.mapIndex = next;
  }
  game.level = game.mapIndex + 1;
  const map = game.maps[game.mapIndex];
  spawnPlayer();
  spawnFromMap(map);
  game.time = 0;
  updateHUD();
}

/* collision helper */
function rectsOverlap(a,b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

/* audio: tiny WebAudio SFX */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function sfx(frequency, type='sine', duration=0.12, gain=0.12){
  try {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = frequency;
    g.gain.value = gain;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + duration);
  } catch(e){}
}
function sfxCollect(){ sfx(880,'sine',0.08,0.12); sfx(1320,'triangle',0.06,0.06); }
function sfxJump(){ sfx(220,'sine',0.14,0.08); }
function sfxHit(){ sfx(120,'sawtooth',0.14,0.18); }

/* ============ Update & Render loop ============ */
function update(dt){
  if(!game.running || game.paused) return;
  const p = game.player;
  // input
  let move = 0;
  if(keys['arrowleft'] || keys['a']) move -= 1;
  if(keys['arrowright'] || keys['d']) move += 1;
  if(touch.active){
    const rect = canvas.getBoundingClientRect();
    const cx = touch.x - rect.left;
    if(cx < rect.width*0.45) move = -1;
    else if(cx > rect.width*0.55) move = 1;
  }
  p.vx += move * p.speed;
  p.vx *= FRICTION;
  // jump
  if((keys['arrowup'] || keys['w'] || keys[' ']) && p.grounded){
    p.vy = JUMP_V - (game.level-1)*0.5;
    p.grounded = false;
    sfxJump();
  }
  p.vy += GRAVITY * 0.8;
  p.x += p.vx * (1 + game.level*0.03);
  p.y += p.vy;

  // floor collision (simple with map)
  const map = game.maps[game.mapIndex];
  const feetY = p.y + p.h;
  // if below bottom area, land on ground
  if(feetY > canvas.height/(window.devicePixelRatio||1) - 8){
    p.y = canvas.height/(window.devicePixelRatio||1) - 8 - p.h;
    p.vy = 0;
    p.grounded = true;
  } else {
    // tile-based collision: check tiles under player
    const underTile = tileAtPixel(map, p.x + p.w/2, feetY);
    if(isSolid(underTile)){
      // snap to tile top
      const row = Math.floor(feetY / TILE);
      p.y = row * TILE - p.h;
      p.vy = 0;
      p.grounded = true;
    } else {
      p.grounded = false;
    }
  }

  // keep inside horizontal bounds
  p.x = Math.max(4, Math.min(p.x, canvas.width/(window.devicePixelRatio||1) - p.w - 4));

  // coins collision
  for(let i=game.coins.length-1;i>=0;i--){
    const c = game.coins[i];
    if(!c.collected && rectsOverlap(p, c)){
      c.collected = true;
      game.score += c.value;
      game.comboTimer = 120; // frames combo window
      sfxCollect();
      updateHUD();
    }
  }
  // enemies update and collision
  for(const e of game.enemies){
    e.x += e.dir * e.speed * (1 + game.level*0.04);
    // simple direction flip at edges
    if(e.x < 8) e.dir = 1;
    if(e.x > canvas.width/(window.devicePixelRatio||1)-40) e.dir = -1;
    if(rectsOverlap(e, p) && !p.dead){
      // hit
      p.dead = true;
      game.lives -= 1;
      updateHUD();
      sfxHit();
      setTimeout(()=>{ 
        p.dead = false;
        // respawn player to start pos
        spawnPlayer();
        if(game.lives <= 0){ gameOver(); }
      }, 700);
    }
  }

  // combo timer reduces
  if(game.comboTimer > 0) game.comboTimer--;

  // level complete: if all coins collected
  const remaining = game.coins.filter(c=>!c.collected).length;
  if(remaining === 0){
    // award combo bonus
    const bonus = Math.max(0, Math.floor((120 - game.comboTimer) / 6));
    game.score += 5 + bonus;
    updateHUD();
    // next level after short delay
    game.paused = true;
    setTimeout(()=>{ game.paused = false; nextLevel(); }, 900);
  }

  game.time += dt;
}

function render(){
  // clear
  const W = canvas.width/(window.devicePixelRatio||1);
  const H = canvas.height/(window.devicePixelRatio||1);
  ctx.fillStyle = '#042033';
  ctx.fillRect(0,0,W,H);

  // draw map (tiles)
  const map = game.maps[game.mapIndex];
  const rows = map.length, cols = map[0].length;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const v = map[r][c];
      const x = c * TILE + 4;
      const y = r * TILE + 4;
      if(v===1){
        // ground block
        drawRect(x,y,TILE-6,TILE-6,'#0f3b3f');
        // top highlight
        ctx.fillStyle = 'rgba(255,255,255,0.03)';
        ctx.fillRect(x,y, TILE-6, 6);
      } else if(v===4){
        drawRect(x,y,TILE-6, TILE/3,'#0f3b3f');
      }
    }
  }

  // draw coins
  for(const c of game.coins){
    if(c.collected) continue;
    // bob
    const bob = Math.sin((game.time + c.x) / 260) * 3;
    const cx = c.x, cy = c.y + bob;
    const r = 10;
    const gx = ctx.createRadialGradient(cx-4, cy-6, 2, cx, cy, r);
    gx.addColorStop(0, '#fff4a8'); gx.addColorStop(0.5,'#ffd24d'); gx.addColorStop(1,'#d6a200');
    ctx.fillStyle = gx;
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
    // shine
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath(); ctx.ellipse(cx - 3, cy - 4, 5, 3, -0.4, 0, Math.PI*2); ctx.fill();
  }

  // draw enemies
  for(const e of game.enemies){
    drawRect(e.x, e.y, e.w, e.h, '#ff7b7b');
    // eye
    ctx.fillStyle = '#2b0f0f';
    ctx.fillRect(e.x + 8, e.y + 8, 6,6);
  }

  // draw player
  const p = game.player;
  if(!p) return;
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.28)';
  ctx.fillRect(p.x+6, p.y + p.h - 6, p.w, 6);
  // body
  ctx.fillStyle = p.color;
  drawRect(p.x, p.y, p.w, p.h, p.color);
  // face
  ctx.fillStyle = '#08121a'; ctx.fillRect(p.x + 6, p.y + 8, 6,6); ctx.fillRect(p.x + p.w-12, p.y + 8, 6,6);

  // HUD overlay small
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(8,8,220,46);
  ctx.fillStyle = '#eaf4ff';
  ctx.font = '13px Inter, system-ui';
  ctx.fillText('Not Coins — Improved', 18, 28);
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.fillText('Collect all coins to advance', 18, 44);
}

/* ============ Game loop runner ============ */
let last = performance.now();
function frame(now){
  const dt = now - last;
  last = now;
  update(dt);
  render();
  requestAnimationFrame(frame);
}

/* ============ HUD and controls ============ */
function updateHUD(){
  scoreEl.textContent = String(game.score);
  livesEl.textContent = String(game.lives);
  levelEl.textContent = String(game.level);
}

/* ============ Leaderboard integration (GET, POST, PUT) ============ */
function leaderboardMsg(text){ networkMsg.textContent = text || ''; }

async function fetchLeaderboard(all=false){
  try {
    leaderboardMsg('Fetching leaderboard...');
    const res = await fetch(API_BASE);
    if(!res.ok) throw new Error('Network failure');
    const data = await res.json();
    data.sort((a,b)=> Number(b.score) - Number(a.score));
    leaderboardMsg('');
    return data;
  } catch(e){
    leaderboardMsg('Unable to fetch leaderboard.');
    throw e;
  }
}

function renderLeaderboard(data, all=false){
  leaderboardEl.innerHTML = '';
  if(!data || data.length===0){ leaderboardEl.innerHTML = '<div class="msg">No scores yet — be the first!</div>'; return; }
  const list = all ? data : data.slice(0, MAX_LEAD_DISPLAY);
  for(const item of list){
    const row = document.createElement('div');
    row.className = 'lead-item';
    row.innerHTML = \`
      <div style="display:flex;flex-direction:column">
        <div class="name">\${escapeHtml(item.name || '—')}</div>
        <div style="font-size:12px;color:var(--muted)">id: \${item.id}</div>
      </div>
      <div class="score">\${Number(item.score)}</div>
    \`;
    leaderboardEl.appendChild(row);
  }
}

function escapeHtml(str){
  return String(str).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

async function fetchAndRenderLeaderboard(all=false){
  leaderboardEl.innerHTML = '<div class="msg">Loading leaderboard…</div>';
  try {
    const data = await fetchLeaderboard();
    renderLeaderboard(data, all);
  } catch(e){
    leaderboardEl.innerHTML = '<div class="msg">Unable to load leaderboard.</div>';
  }
}

async function submitScoreForPlayer(score){
  const STORAGE_KEY = 'notcoins_player';
  const name = localStorage.getItem(STORAGE_KEY);
  if(!name){ leaderboardMsg('No saved player name — cannot submit.'); return; }
  try {
    const listRes = await fetch(API_BASE);
    if(!listRes.ok) throw new Error('Failed to fetch list');
    const list = await listRes.json();
    const found = list.find(p => p.name && p.name.toLowerCase() === name.toLowerCase());
    if(found){
      const existing = Number(found.score) || 0;
      const payload = { name: name, score: Math.max(existing, Number(score)) };
      const putRes = await fetch(`${API_BASE}/${encodeURIComponent(found.id)}`, {
        method:'PUT', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)
      });
      if(!putRes.ok) throw new Error('Failed to update');
      return await putRes.json();
    } else {
      const payload = { name: name, score: Number(score) };
      const postRes = await fetch(API_BASE, {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)
      });
      if(!postRes.ok) throw new Error('Failed to create');
      return await postRes.json();
    }
  } catch(e){
    console.error(e);
    leaderboardMsg('Unable to submit score (network).');
    throw e;
  }
}

/* ============ Name saving (locked) ============ */
const STORAGE_KEY = 'notcoins_player';
function lockNameUI(name){
  playerNameInput.value = name;
  playerNameInput.disabled = true;
  saveNameBtn.disabled = true;
  nameHelp.textContent = "Name saved and locked. To change it clear site data/localStorage.";
}
saveNameBtn.addEventListener('click', ()=>{
  const val = playerNameInput.value.trim();
  if(!val || val.length < 2){ nameHelp.textContent = "Please enter at least 2 characters."; return; }
  try{
    localStorage.setItem(STORAGE_KEY, val);
    lockNameUI(val);
    leaderboardMsg('Name saved. Ready to submit.');
    fetchAndRenderLeaderboard();
  } catch(e){ nameHelp.textContent = "Failed to save name."; }
});
const existingName = localStorage.getItem(STORAGE_KEY);
if(existingName) lockNameUI(existingName);

/* ============ Buttons ============ */
pauseBtn.addEventListener('click', ()=>{ game.paused = !game.paused; pauseBtn.textContent = game.paused ? 'Resume' : 'Pause'; });
restartBtn.addEventListener('click', ()=>{ resetLevel(0); });

refreshBtn.addEventListener('click', ()=> fetchAndRenderLeaderboard(false));
showAllBtn.addEventListener('click', ()=>{
  const all = showAllBtn.dataset.all === '1';
  if(all){ showAllBtn.dataset.all='0'; showAllBtn.textContent='Show All'; fetchAndRenderLeaderboard(false); }
  else { showAllBtn.dataset.all='1'; showAllBtn.textContent='Show Top'; fetchAndRenderLeaderboard(true); }
});

/* ============ Game Over and submit ============ */
function gameOver(){
  game.running = false;
  game.paused = true;
  leaderboardMsg('Game over — submitting score...');
  submitScoreForPlayer(game.score).then(()=>{ leaderboardMsg('Score submitted.'); fetchAndRenderLeaderboard(); }).catch(()=>{ leaderboardMsg('Unable to submit score.'); });
}

/* try to submit with navigator.sendBeacon on unload */
window.addEventListener('beforeunload', ()=> {
  const name = localStorage.getItem(STORAGE_KEY);
  if(!name) return;
  if(game.score > 0 && navigator.sendBeacon){
    try{
      // send as JSON blob if possible (some browsers support)
      const payload = JSON.stringify({ name, score: game.score });
      navigator.sendBeacon(API_BASE, payload);
    } catch(e){}
  }
});

/* ============ Init ============ */
game.maps = createMaps();
resetLevel(0);
fetchAndRenderLeaderboard(false);
requestAnimationFrame(frame);

/* For debugging keys to add score / damage */
window.addEventListener('keydown', e => {
  if(e.key === 'p'){ game.score += 3; updateHUD(); }
  if(e.key === 'o'){ game.lives = Math.max(0, game.lives - 1); updateHUD(); if(game.lives<=0) gameOver(); }
});

</script>
</body>
</html>
